<div id="canvas-container" aria-hidden="true"></div>

<script>
  import * as THREE from 'three';
  import { gsap } from 'gsap';

  // ============================================
  // MINIMAL ELEGANT THREE.JS BACKGROUND
  // Professional, modern design with small floating particles
  // Clean and subtle - complements background image
  // ============================================

  // Configuration - Minimal, Elegant Theme
  const CONFIG = {
    // Colors - Subtle, professional palette
    primaryTeal: 0x78cbcd,        // Brand teal
    lightTeal: 0xa5e1e3,          // Lighter teal
    softWhite: 0xffffff,          // Pure white
    warmGold: 0xffd89e,           // Subtle gold accent

    // Small floating particles only
    particleCount: 80,

    // Animation speeds - subtle and smooth
    floatSpeed: 0.2,
  };

  // Setup
  const container = document.getElementById('canvas-container');
  if (!container) throw new Error('Canvas container not found');

  const scene = new THREE.Scene();

  // Camera
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.z = 600;

  // Renderer with transparency
  const renderer = new THREE.WebGLRenderer({
    alpha: true,
    antialias: true,
    powerPreference: 'high-performance'
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);
  container.appendChild(renderer.domElement);

  // ============================================
  // FLOATING PARTICLES - Small elegant sparkles
  // Minimal and professional
  // ============================================

  const colors = [
    CONFIG.primaryTeal,
    CONFIG.lightTeal,
    CONFIG.softWhite,
    CONFIG.warmGold
  ];

  const particleCount = CONFIG.particleCount;
  const particleGeometry = new THREE.BufferGeometry();
  const particlePositions = new Float32Array(particleCount * 3);
  const particleSizes = new Float32Array(particleCount);
  const particleColors = new Float32Array(particleCount * 3);

  interface ParticleVelocity {
    x: number;
    y: number;
    z: number;
    phase: number;
  }

  const particleVelocities: ParticleVelocity[] = [];

  for (let i = 0; i < particleCount; i++) {
    // Distribute particles across full viewport
    particlePositions[i * 3] = (Math.random() - 0.5) * 1400;
    particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 900;
    particlePositions[i * 3 + 2] = -50 - Math.random() * 300;

    // Small particle sizes (1-3 range for minimal look)
    particleSizes[i] = 1 + Math.random() * 2;

    const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
    particleColors[i * 3] = color.r;
    particleColors[i * 3 + 1] = color.g;
    particleColors[i * 3 + 2] = color.b;

    particleVelocities.push({
      x: (Math.random() - 0.5) * 0.3,
      y: 0.1 + Math.random() * 0.2,
      z: (Math.random() - 0.5) * 0.2,
      phase: Math.random() * Math.PI * 2
    });
  }

  particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
  particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
  particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

  const particleMaterial = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 }
    },
    vertexShader: `
      attribute float size;
      attribute vec3 color;
      varying vec3 vColor;
      varying float vAlpha;
      uniform float time;

      void main() {
        vColor = color;
        // Gentle opacity variation
        vAlpha = 0.4 + 0.3 * sin(time * 0.5 + position.x * 0.01);

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (400.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying float vAlpha;

      void main() {
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;

        // Soft circular particle with smooth edges
        float alpha = smoothstep(0.5, 0.1, dist) * vAlpha * 0.6;
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const particles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particles);

  // ============================================
  // GSAP INTEGRATION - Smooth entrance animation
  // ============================================

  // Initial state - particles start hidden
  particles.scale.setScalar(0);
  particles.material.opacity = 0;

  // GSAP Timeline for entrance animation
  const entranceTimeline = gsap.timeline({
    defaults: { ease: 'power3.out' }
  });

  // Animate particles appearing
  entranceTimeline.to(particles.scale, {
    x: 1,
    y: 1,
    z: 1,
    duration: 1.5,
    ease: 'power2.out'
  }, 0.3);

  // ============================================
  // MOUSE INTERACTION - Subtle parallax
  // ============================================

  let mouseX = 0;
  let mouseY = 0;
  let targetMouseX = 0;
  let targetMouseY = 0;

  function onMouseMove(event: MouseEvent) {
    targetMouseX = (event.clientX / window.innerWidth - 0.5) * 50;
    targetMouseY = (event.clientY / window.innerHeight - 0.5) * 50;
  }

  window.addEventListener('mousemove', onMouseMove);

  // ============================================
  // RESIZE HANDLER
  // ============================================

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  window.addEventListener('resize', onWindowResize);

  // ============================================
  // ANIMATION LOOP
  // ============================================

  let startTime = Date.now();
  let animationId: number;

  function animate() {
    animationId = requestAnimationFrame(animate);

    const time = (Date.now() - startTime) * 0.001;

    // Smooth mouse interpolation
    mouseX += (targetMouseX - mouseX) * 0.03;
    mouseY += (targetMouseY - mouseY) * 0.03;

    // Update particles with gentle floating motion
    const positions = particles.geometry.attributes.position.array as Float32Array;
    for (let i = 0; i < particleCount; i++) {
      const vel = particleVelocities[i];

      // Gentle side-to-side motion
      positions[i * 3] += Math.sin(time * 0.3 + vel.phase) * vel.x * 0.5;
      // Slow upward drift
      positions[i * 3 + 1] += vel.y * 0.5;
      // Subtle depth movement
      positions[i * 3 + 2] += Math.cos(time * 0.2 + vel.phase) * vel.z * 0.3;

      // Reset particles that float too high
      if (positions[i * 3 + 1] > 500) {
        positions[i * 3 + 1] = -450;
        positions[i * 3] = (Math.random() - 0.5) * 1400;
      }
    }
    particles.geometry.attributes.position.needsUpdate = true;
    (particleMaterial).uniforms.time.value = time;

    // Subtle camera movement based on mouse
    camera.position.x = mouseX * 0.02;
    camera.position.y = mouseY * 0.02;
    camera.lookAt(0, 0, -100);

    renderer.render(scene, camera);
  }

  animate();

  // ============================================
  // CLEANUP (for page navigation in SPA)
  // ============================================

  document.addEventListener('astro:before-preparation', () => {
    cancelAnimationFrame(animationId);
    window.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('resize', onWindowResize);
    entranceTimeline.kill();
    renderer.dispose();
    scene.clear();
  });
</script>

<style>
  #canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
    overflow: hidden;
  }
</style>
